#!/usr/bin/env perl

use warnings;
use strict;
use File::Path qw( make_path );
use File::Fetch;
# use Archive::Tar;
# use IO::Uncompress::Gunzip;
# use IO::Uncompress::AnyUncompress;
# use IO::Uncompress::AnyUncompress qw(anyuncompress $AnyUncompressError);
use File::Find;
use File::Basename;
# use LWP::UserAgent;
# use HTTP::Request;
use IO::Handle;
use Term::ANSIColor;
use List::Util qw(max);

$| = 1;  # or
STDOUT->autoflush(1);

# # todo {{{
# # TODO: Add progress bar for the fetch();
# use LWP::Simple;
# use Time::HiRes qw(sleep time);
# use File::Temp qw(tempfile);
# use IO::Socket::INET;
# use HTTP::Request;
# use HTTP::Response;

# use IO::Socket::INET;
# use IO::Socket::SSL;  # For HTTPS support
# use threads;

# use Term::ProgressBar;
# # }}}

# variables {{{
my $prompt = basename($0);
my $steps = 0;
my $home = $ENV{'HOME'};
my $root_dir = $home.'/.local/set-me-up';
my %path = (
    tarball => $root_dir."/tarballs",
    bin => $home.'/.bin',
);

# external tools {{{
my %tool_list = (
    typst  => {
        api_url => 'https://api.github.com/repos/typst/typst/releases/latest',
        file_regex => qr/typst-x86_64-unknown-linux-musl\.tar\.xz/,
    },
    jira   => {
        api_url => 'https://api.github.com/repos/ankitpokhrel/jira-cli/releases/latest',
        file_regex => qr/jira_(\d+\.\d+\.\d+)_linux_x86_64\.tar\.gz/,
    },
    v2raya => {
        api_url => 'https://api.github.com/repos/v2rayA/v2rayA/releases/latest',
        file_regex => qr/v2raya_linux_x64_(\d+\.\d+\.\d+\.\d+)/,
    },
    gum    => {
        api_url => 'https://api.github.com/repos/charmbracelet/gum/releases/latest',
        file_regex => qr/gum_(\d+\.\d+\.\d+)_Linux_x86_64\.tar\.gz/,
    },
    # go => {
    #     url => 'https://go.dev/dl/',
    #     regex => qr/go(\d+\.\d+\.\d+)\.linux-amd64\.tar\.gz/,
    # },
);
# }}}

# }}}

# helper functions {{{

# finder {{{
sub wanted {
    my $pattern = $_[0];
    my $type = $_[1];
    $type ||= 'f';

    if ($type eq 'f') {
        if (-f $File::Find::name && $File::Find::name =~ /$pattern/) {
            return $File::Find::name;
        }
    } elsif ($type eq 'd') {
        if (-d $File::Find::name && $File::Find::name =~ /$pattern/) {
            return $File::Find::name;
        }
    }
}
# }}}

# # spinner {{{
# sub spinner {
#     # my @spinner_chars = ('|', '/', '-', '\\');
#     # my @spinner_chars = ('.', '!', '|', '+', '=', '#');
#     my @spinner_chars = ('@', '#','@', '#','@', '#','@', '#',);
#     my $i = 0;
#     my $delay = 0.5;
#
#     while (1) {
#         print();
#         $| = $delay;  # Enable autoflush
#         sleep($delay);  # Adjust the speed of the spinner
#     }
#
# }
# # }}}

# logger {{{
sub logger {
    my ($prefix, $message, $level) = @_;
    $level //= 1;

    my $msg = sprintf('[%s %s]',
        $prefix,
        $message,
    );

    print($msg);
    print(" ");

    exit 1 if $level gt 2;
}
# }}}

# funny messages {{{
sub whoa_wait {
my $whatnow;
    my @greetings = (
        "Alright.",
        "Whoa wait",
        "What happend?",
        "Are you Okay?",
        "Fine.",
        "I'm not gonna do anything",
        "It is what it is",
        "After you!",
        "So that how it ends",
        "hmmm...",
    );
    print(STDERR "\n> $greetings[int rand@greetings]\n");
}
# }}}

# array to string {{{
sub array_to_string {
    my @array = $_[0];
    my $string = join('\\n', @array);
    $string =~ tr/\n/ /;
    $string =~ s/ +/ /g;
    $string =~ s/^ //g;
    return $string;
}
# }}}

# # get file size before download {{{
# sub get_file_size {
#     my ($url) = @_;
#     
#     # Parse the URL
#     my ($protocol, $host, $path) = $url =~ m{^(https?://)?([^/]+)(/.*)?$};
#     $host =~ s{^https?://}{};  # Remove protocol
#     my $port = $protocol ? 443 : 80;  # Use 443 for HTTPS, 80 for HTTP
#
#
#     # Create a socket connection
#     my $socket = IO::Socket::INET->new(
#         PeerHost => $host,
#         PeerPort => $port,
#         Proto    => 'tcp',
#     ) or die "Could not connect to $host: $!";
#
#     # Send a HEAD request
#     print $socket "GET $path HTTP/1.0\r\n";
#     print $socket "Host: $host\r\n";
#     print $socket "User-Agent: PerlScript/1.0\r\n";  # Add User-Agent
#     print $socket "Connection: close\r\n\r\n";
#
#
#
#     # Read the response
#     my $response = '';
#     while (<$socket>) {
#         $response .= $_;
#         last if /^\r\n$/;  # End of headers
#     }
#     close($socket);
#
#     print "Response Headers:\n$response\n";
#
#     # Extract Content-Length from the response headers
#     if ($response =~ /Content-Length:\s*(\d+)/i) {
#         return $1;  # Return the file size
#     }
#     return 0;  # Default to 0 if not found
# }
# # }}}

# downloader {{{
sub fetch {
    unless (-d $root_dir) {
        make_path($root_dir);
    }
    make_path($path{tarball});

    my $url = $_[0];
    my $name = $_[1];
    my $output_file = $path{tarball};
    my $ff = File::Fetch->new(uri => $url);
    my $file = basename($url);
    my $full_name = $output_file.'/'.$ff->file;

    my $return_value = {
        name => $name,
        url => $url,
        file => $ff->file,
        full_name => $full_name,
    };

    if (-f $full_name) {
        print(STDERR "[".color("bold blue")."ignore".color("reset")."] file already exists ");
        return $return_value;
    }

    # printf(STDERR '  %s at %s', $file, $path{tarball});
    # print(STDERR "\n");
    # printf(STDERR '  url: %s', $url);

    my $where = $ff->fetch(to => $path{tarball}) or logprint($ff->error, 2);  # fetch

    # print(STDERR "\tname: $name, url: $url\n");

    # my $ff->output_file = $path{tarball}.$ff->file;
    # my $file = $ff->fetch() or die $ff->error;
    # my $fname = basename($where);
    # rename $where, "$dir/$fname";

    # print(STDERR $ff->uri);
    # print(STDERR "\n");
    # print(STDERR $ff->scheme);
    # print(STDERR "\n");
    # print(STDERR $ff->host);
    # print(STDERR "\n");
    # print(STDERR $ff->path);
    # print(STDERR "\n");
    # print(STDERR $ff->file);
    # print(STDERR "\n");
    # print(STDERR $ff->output_file);
    # print(STDERR "\n");

    return $return_value;
}
# }}}

# get url from http json response {{{
sub get_url_from_json_response {
    my ($json_text) = @_;
    my @urls;
    while ($json_text =~ /"browser_download_url"\s*:\s*"([^"]+)"/g) {
        push @urls, $1;
    }
    return @urls;
}
# }}}

# archive and compression {{{
sub unarchive {
    my ($file_input, $file_output) = @_;
    my @cmd;
    if ($file_input =~ /\.tar/) {
        @cmd = ("tar", "-xf", "$file_input", "-C", "$file_output");
    } elsif ($file_input =~ /\.zip/) {
        @cmd = ("unzip", "xf", "$file_input", "-d", "$file_output");
    } elsif ($file_input =~ /\.rar/) {
        @cmd = ("unrar", "x", "$file_input", "-ad", "$file_output");
    } else {
        return 1;
    }
    my $status = system(@cmd);
    if ($status) {
        return 0;
    }
}

sub decompress {
    my ($file_input) = @_;
    my @cmd;
    if ($file_input =~ /\.xz$/) {
        @cmd = ("unxz", "$file_input");
    } elsif ($file_input =~ /\.gz$/) {
        @cmd = ("gunzip", "$file_input");
    } elsif ($file_input =~ /\.zstd$/) {
        @cmd = ("unzstd", "$file_input");
    } elsif ($file_input =~ /\.bz2/) {
        @cmd = ("unbzip2", "$file_input");
    } else {
        return 1;
    }
    my $status = system(@cmd);
    if ($status) {
        return 0;
    }
}
# }}}

# live log {{{
sub live_log {
    my $steps = $_[1];
    my $tool_count = $_[2];
    my $total_tools = $_[3];
    my $stage = $_[4];
    my $tool = $_[5];
    my $current_length = $_[6];

    printf(STDERR '%s [%s] [%s/%s] %s %s%s',
        color("bold cyan").$prompt.color("reset"),
        $steps,
        $tool_count,
        $total_tools,
        color("bold magenta").$stage.color("reset"),
        $tool,
        " "x$current_length
    );
}
# }}}

# }}}

# }}}

# let's stay quiet for now

my $length = 0;

while (my ($tool, $info) = each %tool_list) {
    my $tl = length($tool);
    if ($tl gt $length) {
        $length = $tl;
    }
}

# external tools {{{
sub external_tools {
    my $ua = LWP::UserAgent->new;
    my @tarballs;
    my @installs;

    @tarballs = fetch_tools($ua);
    @installs = extract_tools(\@tarballs);
    install_tools(\@installs);
}
# }}}

# fetch tools {{{
sub fetch_tools {
    my ($ua) = @_;
    my $total_tools = scalar(keys %tool_list);
    my $tool_count = 0;
    my @tarballs;
    $steps++;  # 1

    print(STDERR "\n==== Fetch External Tools ====\n\n");
    while (my ($tool, $info) = each %tool_list) {
        $tool_count++;
        my $current_length = max(0, $length - length($tool) + 1);
        live_log($prompt, $steps, $tool_count, $total_tools, "fetch", $tool, $current_length);
        
        if (exists $info->{api_url}) {
            my $response = $ua->get($info->{api_url});
            if ($response->is_success) {
                my $content = $response->decoded_content;
                foreach my $json ($content) {
                    my @download_urls = get_url_from_json_response($json);
                    foreach my $tool_url (@download_urls) {
                        if ($tool_url =~ /$tool_list{$tool}{file_regex}/) {
                            push(@tarballs, fetch($tool_url, $tool));  # fetch
                            last;
                        }
                    }
                }
                print(STDERR "[".color("bold green")."success".color("reset")."]");
            } else {
                print(STDERR "[".color("bold red")."failure".color("reset")."] ".$response->status_line);
            }
        } elsif (exists $info->{url}) {
            my $response = $ua->get($info->{url});
            if ($response->is_success) {
                my $content = $response->decoded_content;
                if ($content =~ $info->{regex}) {
                    my $version = $1;
                    my $download_url = "$info->{url}/go$version.linux-amd64.tar.gz";
                    push(@tarballs, fetch($download_url, $tool));  # fetch
                } else {
                    print(STDERR "failed to find version for $tool");
                }
                print(STDERR "\rdone");
            } else {
                print(STDERR "failed: ", $response->status_line);
            }
        } else {
            print(STDERR "failed: no API URL or direct URL for $tool");
        }
        print(STDERR "\n");
    }
    print(STDERR "\nfetch download completed\n");
    return @tarballs;
}
# }}}
# extract tools {{{
sub extract_tools {
    my ($tarballs_ref) = @_;
    my $total_tools = scalar(@$tarballs_ref);
    my $tool_count = 0;
    my @installs;
    $steps++;  # 2

    print(STDERR "\n==== Extract External Tools ====\n\n");
    for my $content (@$tarballs_ref) {
        $tool_count++;
        my $full_name = $content->{full_name};
        my $tool      = $content->{name};
        my $current_length = max(0, $length - length($tool) + 1);
        live_log($prompt, $steps, $tool_count, $total_tools, "extract", $tool, $current_length);
        unless (-e $full_name) {
            print(STDERR "[".color("bold red")."failure".color("reset")."]: ".$!, "\n");
            next;
        }

        my $extract_path = dirname($full_name);
        my $status = decompress($full_name);
        if ($status) {
            print(STDERR "[".color("bold yellow")."decompress".color("reset")."] ready to install ");
            $status = unarchive($full_name, $extract_path);
        }
        if ($status) {
            print(STDERR "[".color("bold green")."success".color("reset")."]");
            push(@installs, $full_name);
        }
        print(STDERR "\n");
    }
    print(STDERR "\nextracting tarballs finished\n");
    return @installs;
}

# }}}
# install tools {{{
sub install_tools {
    my ($installs_ref) = @_;
    my $tool_count = 0;
    my $total_tools = scalar(@$installs_ref);
    $steps++;  # 3

    print(STDERR "\n==== Install External Tools ====\n\n");
    for my $tool (@$installs_ref) {
        $tool_count++;
        my $current_length = max(0, $length - length($tool) + 1);
        live_log($prompt, $steps, $tool_count, $total_tools, "install", $tool, $current_length);
        
        # Here you would implement the installation logic for each tool
        # For example, you might want to move the binary to a specific directory
        # or run an installation script if applicable.
        
        # Example installation logic (this is just a placeholder):
        my $install_status = install_binary($tool);
        if ($install_status) {
            print(STDERR "[".color("bold green")."success".color("reset")."]");
        } else {
            print(STDERR "[".color("bold red")."failure".color("reset")."]");
        }
        print(STDERR "\n");
    }
    print(STDERR "\ninstalling tools finished\n");
}

sub install_binary {
    my ($binary) = @_;
    # Implement the actual installation logic here
    # This is a placeholder function that should return true on success
    return 1;  # Change this to actual installation logic
}
# }}}

# mint {{{
sub mint {
    my $err;

    # package list {{{
    my @packages = ();

    # archive tools {{{
    my @pkg_comp = (
        "atool",
        "arc",
        "arj",
        "lzip",
        "lzop",
        "nomarch",
        "rar",
        "rpm",
        "unace",
        "unalz",
        "unrar",
        "unzip",
        "7zip",
        "bzip2",
        "p7zip",
        "p7zip-full",
        "xz-utils",
        "zip",
        "zstd",
    );
    # }}}

    # daily tools {{{
    my @pkg_hos = (
        "highlight",
        "lynx",
        "pwgen",
        "links",
        "build-essential",
        "ed",
        "fzf",
        "bc",
        "jq",
        "lf",
        "aria2",
        "curl",
        "asciidoctor",
        "btop",
        "ffmpeg",
        "ffmpegthumbnailer",
        "gpg",
        "imagemagick",
        "imagemagick",
        "make",
        "mg",
        "moreutils",
        "mupdf-tools",
        "neofetch",
        "neovim",
        "nnn",
        "nsxiv",
        "pandoc",
        "pass",
        "patch",
        "pinentry-curses",
        "rsync",
        "tmux",
        "tmuxinator",
        "udisks2",
        "vim",
        "wget",
        "xclip",
        "xsel",
        "xwallpaper",
        "yad",
        "yq",
        "yt-dlp",
        "zathura",
        "zathura-pdf-poppler",
        "zsh",
        "zsh-antigen",
        "qrencode",
        "simplescreenrecorder",
        "sshfs",
    );
    # }}}

    # misc {{{
    my @pkg_misc = (
        "qt5-gtk-platformtheme",
        "qt5-gtk2-platformtheme",
        "qt5-style-plugin-cleanlooks",
        "qt5-style-plugins",
        "dmz-cursor-theme",
        "fprintd",
        "gimp",
        "gufw",
        "ufw",
        "lm-sensors",
        "ntfs-3g",
        "lshw",
        "lsof",
        "lvm2",
        "net-tools",
        "netcat-openbsd",
        "nmap",
        "openfortivpn",
        "openconnect",
        "openssh-server",
        "openvpn",
        "onboard",
    );
    # }}}

    # vm/lxc {{{
    my @pkg_isolate = (
        "podman",
        "docker-compose",
        "docker-buildx",
        "docker.io",
        "ansible",
        "qemu-system",
        "qemu-utils",
        "virt-manager",
        "virt-viewer",
    );
    # }}}

    # LaTeX {{{
    my @pkg_tex = (
        "texlive-fonts-recommended",
        "texlive-latex-base",
        "texlive-latex-extra",
        "texlive-latex-recommended",
        "texlive-xetex",
    );
    # }}}

    # dev tools {{{
    my @pkg_dev = (
        "g++",
        "gcc",
        "git",
        "golang",
        "libyaml-tiny-perl",
        "lua5.1",
        "lua5.2",
        "lua5.3",
        "lua5.4",
        "nodejs",
        "npm",
        "pipx",
        "pkg-config",
        "pkgconf",
        "pkgconf-bin",
        "python-is-python3",
        "python3",
        "python3-pip",
        "python3-venv",
        "python3-pygments",
        "rake",
        "ruby",
        "ruby-asciidoctor",
        "ruby-asciidoctor-include-ext",
        "ruby-asciidoctor-pdf",
        "ruby-pygments.rb",
        "ruby-rouge",
        "tree-sitter-cli",
    );
    # }}}

    # header files {{{
    my @pkg_header = (
        "libcairo2-dev",
        "libcrypt-dev",
        "libfreetype-dev",
        "libfribidi-dev",
        "libgraphite2-dev",
        "libharfbuzz-dev",
        "libjpeg-turbo8-dev",
        "libncurses-dev",
        "libplayerctl-dev",
        "libpng-dev",
        "libstartup-notification0-dev",
        "libx11-dev",
        "libx11-xcb-dev",
        "libxcb-cursor-dev",
        "libxcb-icccm4-dev",
        "libxcb-image0-dev",
        "libxcb-keysyms1-dev",
        "libxcb-randr0-dev",
        "libxcb-render-util0-dev",
        "libxcb-render0-dev",
        "libxcb-shape0-dev",
        "libxcb-shm0-dev",
        "libxcb-util-dev",
        "libxcb-util0-dev",
        "libxcb-xfixes0-dev",
        "libxcb-xinerama0-dev",
        "libxcb-xkb-dev",
        "libxcb-xrm-dev",
        "libxcb-xtest0-dev",
        "libxcb1-dev",
        "libxdg-basedir-dev",
        "libxdmcp-dev",
        "libxext-dev",
        "libxft-dev",
        "libxinerama-dev",
        "libxkbcommon-dev",
        "libxkbcommon-x11-dev",
        "libxml2-dev",
        "libxrandr-dev",
        "libxrender-dev",
        "libyaml-dev",
    );
    # }}}

    push(@packages, @pkg_dev);
    push(@packages, @pkg_hos);
    push(@packages, @pkg_comp);
    push(@packages, @pkg_misc);
    push(@packages, @pkg_header);
    # push(@packages, @pkg_tex);
    push(@packages, @pkg_isolate);
    # }}}

    print(STDERR "\n==== Updating Repositories ====\n\n");
    $err = system("sudo", "apt-get", "update", "-y");
    if ($err) {
        whoa_wait();
        exit $err / 255;
    }

    print(STDERR "\n==== Installing Packages ====\n\n");
    print(STDERR "sudo apt-get install @packages\n");
    $err = system("sudo", "apt-get", "install", "@packages");
    if ($err) {
        whoa_wait();
        exit $err / 255;
    }

    # for my $package (@packages) {
    #     print(STDERR "[$package]");
    #     # system("sudo apt install $package");
    # }

}
# }}}

# void {{{
sub void {
    my $subname = (caller(0))[3];
    my $err;

    # package list {{{
    my @packages = ();

    # archive tools {{{
    my @pkg_comp = (
        "atool",
        "lzip",
        "lzop",
        "rpm",
        "unrar",
        "unzip",
        "7zip",
        "bzip2",
        "p7zip",
        # "p7zip-unrar",
        "7zip-unrar",
        "xz",
        "zip",
        "zstd",
    );
    # }}}

    # daily tools {{{
    my @pkg_hos = (
        "fastfetch",
        "onefetch",
        "highlight",
        "lynx",
        "pwgen",
        "links",
        "ed",
        "fzf",
        "bc",
        "jq",
        "lf",
        "aria2",
        "curl",
        "btop",
        "ffmpeg",
        "ffmpegthumbnailer",
        "gnupg",
        "ImageMagick",
        "make",
        "mg",
        "moreutils",
        "mupdf-tools",
        "neofetch",
        "neovim",
        "nnn",
        "nsxiv",
        "pandoc",
        "pass",
        "patch",
        "rsync",
        "tmux",
        "udisks2",
        "vim",
        "wget",
        "xclip",
        "xsel",
        "xwallpaper",
        "yad",
        "yq",
        "yt-dlp",
        "zathura",
        "zathura-pdf-poppler",
        "zsh",
        "qrencode",
        "ssr",
        "fuse-sshfs",
    );
    # }}}

    # misc {{{
    my @pkg_misc = (
        "qt5-styleplugins",
        "kf6-qqc2-desktop-style",
        "breeze-qt5",
        "breeze-qt6",
        "xcursor-vanilla-dmz-aa",
        "xcursor-vanilla-dmz",
        "fprintd",
        "gimp",
        "gufw",
        "ufw",
        "lm_sensors",
        "ntfs-3g",
        "lshw",
        "lsof",
        "lvm2",
        "net-tools",
        "openbsd-netcat",
        "nmap",
        "openfortivpn",
        "openconnect",
        "openssh",
        "openvpn",
        "onboard",
    );
    # }}}

    # vm/lxc {{{
    my @pkg_isolate = (
        "podman",
        "docker-compose",
        "docker-buildx",
        "docker",
        "ansible",
        "qemu",
        "qemu-img",
        "qemu-tools",
        "qemu-user",
        "virt-manager",
        "virt-viewer",
    );
    # }}}

    # LaTeX {{{
    my @pkg_tex = (
        "texlive2025-bin-2025_2",
    );
    # }}}

    # dev tools {{{
    my @pkg_dev = (
        "gcc",
        "git",
        "go",
        "perl-YAML-LibYAML",
        "perl-YAML-Tiny",
        "lua51",
        "lua52",
        "lua53",
        "lua54",
        "nodejs",
        "python3-pipx",
        "pkg-config",
        "pkgconf",
        "python3",
        "python3-pip",
        "python3-Pygments",
        "ruby",
        "ruby-asciidoctor",
        "tree-sitter",
    );
    # }}}

    # header files {{{
    my @pkg_header = (
        "cairo-devel",
        "freetype-devel",
        "fribidi-devel",
        "graphite-devel",
        "harfbuzz-devel",
        "libjpeg-turbo-devel",
        "ncurses-devel",
        "playerctl-devel",
        "libpng-devel",
        "startup-notification-devel",
        "libX11-devel",
        "libxcb-devel",
        "xcb-util-cursor-devel",
        "xcb-util-wm-devel",
        "xcb-util-image-devel",
        "xcb-util-keysyms-devel",
        "xcb-util-renderutil-devel",
        "libxshmfence-devel",
        "xcb-util-image-devel",
        "libXfixes-devel",
        "libXinerama-devel",
        "libxkbcommon-devel",
        "libxkbfile-devel",
        "xcb-util-xrm-devel",
        "libxdg-basedir-devel",
        "libXdmcp-devel",
        "libXext-devel",
        "libXft-devel",
        "libxml2-devel",
        "libXrandr-devel",
        "libXrender-devel",
        "libyaml-devel",
    );
    # }}}

    push(@packages, @pkg_dev);
    push(@packages, @pkg_hos);
    push(@packages, @pkg_comp);
    push(@packages, @pkg_misc);
    push(@packages, @pkg_header);
    push(@packages, @pkg_tex);
    push(@packages, @pkg_isolate);
    # }}}

    # extra repos {{{
    logger($subname, "enable extra repositories");
    my $output = `sudo xbps-install -Syu void-repo-nonfree void-repo-multilib void-repo-multilib-nonfree`;
    $err = $? >> 8;
    if ($err) {
        print("\n");
        whoa_wait();
        exit $err;
    } else {
        print("done\n");
    }
    logger($subname, "update repositories");
    $output = `sudo xbps-install -Sy`;
    $err = $? >> 8;
    if ($err) {
        print("\n");
        whoa_wait();
        exit $err;
    } else {
        print("done\n");
    }
    # }}}

    # upgrade {{{
    logger($subname, "system upgrade");
    $output = `sudo xbps-install -Su`;
    $err = $? >> 8;
    if ($err) {
        print("\n");
        whoa_wait();
        exit $err / 255;
    } else {
        print("done\n");
    }
    # }}}

    # install {{{
    logger($subname, "install packages from repository");
    logger($subname, "\$ sudo xbps-install @packages");
    print("\n");
    $output = `sudo xbps-install @packages`;
    $err = $? >> 8;
    if ($err) {
        print("\n");
        whoa_wait();
        exit $err / 255;
    } else {
        print("done\n");
    }
    # }}}

}
# }}}

# mint();
void();
# external_tools();
# spinner();

